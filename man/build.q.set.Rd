\name{build.q.set}
\alias{build.q.set}
\title{Q methodology: Sample a Q set from a concourse}
\description{
  Subsets a concourse of items into a sample of selected items.
  Returns a dataframe with (meaningful, short) handles as rownames, and languages (if applicable) as columns.
}
\usage{
  build.q.set(q.concourse, q.sample, q.distribution)
}

\arguments{
  \item{q.concourse}{
    A matrix with (meaningful, short) handles as row names, languages (if applicable) as columns, and full items in cells as produced by \code{\link{import.q.concourse}}.
  }
  \item{q.sample}{
    A character vector of sampled (meaningful, short) handles, such as \code{c("q-is-great","q-is-obscure")}.
  }
  \item{q.distribution}{
    The chosen Q distribution as a vector of integers, such as \code{c(1,3,1)}.
  }
}
\details{
  Q studies are carried out letting participants rank a \emph{sample} of statements (items), collectively referred to as the \emph{Q set}.
  These Q sets are drawn (by some sampling strategy) from a \emph{concourse}, or universe of items.
  This function subsets the concourse generated by \code{\link{import.q.concourse}}, based on a vector of (meaningful, short) handles provided, and returns it as \code{q.set}.

  The function implements a number of tests on the validity and consistency of inputs.

  More details on the files and directory structure expected by this function can be found in the \link{qmethod-package} documentation, and on the package \href{https://github.com/aiorazabala/qmethod/wiki/Data-management}{wiki}.
}

\value{
  Returns a matrix with (meaningful, short) handles (\code{''q-is-great''}, for example) as row names, languages (if applicable) as columnames and full wordings in cells.
}

\note{
  This function currently does \emph{not} actually \emph{draw} a sample, but merely builds the Q set from a \emph{given} sample.
  Comment and/or chip in if you like want an actual sampling feature: \url{https://github.com/aiorazabala/qmethod/issues/5}.

  This function currently requires a \code{q.distribution}, but it only checks for the sum, so if you are working with a distribution-free study that still has a fixed number of items (as most will), you can just enter a vector of length 1 with your total sum of items.
}

\author{Maximilian Held}

\seealso{
  \code{\link{import.q.concourse}},
  \code{\link{import.q.feedback}},
  \code{\link{import.q.sorts}},
  \code{\link{make.cards}}
}

\examples{
  ## Build a Q Set from a concourse and a sample
  data(importexample)
  q.set <- build.q.set(
    q.concourse = importexample$q.concourse,  # as created by import.q.concourse
    q.sample = c("life-with-q","q-uprising","r-dominance","small-village"),
    # add vector with items to be selected from concourse
    # q.sample is ideally read in from a separate CSV
    q.distribution = c(1,2,1) # very simple distribution,
  )
}
